\documentclass[11pt]{amsart}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}

\usepackage{amsmath, amssymb, amsthm, amscd}
\usepackage{url}
\usepackage{graphicx}
\usepackage[hidelinks,pagebackref,pdftex]{hyperref}
\usepackage{color}
\usepackage{import}
\usepackage[margin=3cm]{geometry}

%%  If the following line is uncommented, we see the labels of theorems, 
%% figures, etc. in the margins.
%\usepackage[notref,notcite]{showkeys}

%% Fix margin notes
\usepackage{marginnote}
%% \catcode `\@=11
% Tiny marginpars 
\long\def\@savemarbox#1#2{\global\setbox#1\vtop{\hsize\marginparwidth 
  \@parboxrestore\tiny\raggedright #2}}
\marginparwidth .75in \marginparsep 7pt 
%% \long\def\flag#1#2{\framebox{#1}\marginpar{#2}}
%% \long\def\sotto#1{{\bf [[} {\em #1 } {\bf ]]}}
%% \catcode`\@=12
\newcommand\marginkris[1]{{\tiny \marginnote{{\color{blue} #1}}} \normalmarginpar}
\newcommand\marginclem[1]{{\tiny \marginnote{{\color{red} #1}}} \normalmarginpar}


%% For hyperref
\renewcommand{\backreftwosep}{\backrefsep}
\renewcommand{\backreflastsep}{\backrefsep}
\renewcommand*{\backref}[1]{}
\renewcommand*{\backrefalt}[4]{
  \ifcase #1
  [No citations.]
  \or [#2]
  \else [#2]
  \fi }

%%This command stops the Math Review numbers appearing in the references! 
\AtBeginDocument{%
   \def\MR#1{}
}

%% Theorems, etc
\numberwithin{equation}{section}
\theoremstyle{plain}
\newtheorem{theorem}[equation]{Theorem}
\newtheorem{conjecture}[equation]{Conjecture}
\newtheorem{lemma}[equation]{Lemma}
\newtheorem{corollary}[equation]{Corollary}
\newtheorem{proposition}[equation]{Proposition}

%% Named theorem environment
\newtheorem*{namedtheorem}{\theoremname}
\newcommand{\theoremname}{testing}
\newenvironment{named}[1]{\renewcommand{\theoremname}{#1}\begin{namedtheorem}}{\end{namedtheorem}}

%% Definitions, etc
\theoremstyle{definition}
\newtheorem{definition}[equation]{Definition}
\newtheorem{example}[equation]{Example}
\newtheorem{remark}[equation]{Remark}
\newtheorem{question}[equation]{Question}

%% Simplifying commands, symbols, etc
\newcommand{\from}{\colon} % As in ``f maps \_from\_ X \_to\_ Y''.
\newcommand{\R}{{\mathbb{R}}}
\newcommand{\Z}{{\mathbb{Z}}}
\newcommand{\N}{{\mathbb{N}}}
\newcommand{\C}{{\mathbb{C}}}
\newcommand{\Q}{{\mathbb{Q}}}

\newcommand{\RP}{\mathbb{R}P}

\newcommand{\tri}{\mathfrak{T}}
\newcommand{\M}{M}

\newcommand{\bdy}{\partial}
\newcommand{\tw}{\operatorname{tw}}
\newcommand{\cng}{\operatorname{cng}}
\newcommand{\dist}{\mathrm{dist}}
\newcommand{\poly}{\mathrm{poly}}
\newcommand{\width}{\mathrm{width}}

%% Shortcuts to refer to things (requires careful naming)
\newcommand{\refarg}[1]{\hfill {\small {\bf Lemma~\ref{lem:#1}}}}
\newcommand{\refthm}[1]{Theorem~\ref{Thm:#1}}
\newcommand{\reflem}[1]{Lemma~\ref{Lem:#1}}
\newcommand{\refprop}[1]{Proposition~\ref{Prop:#1}}
\newcommand{\refcor}[1]{Corollary~\ref{Cor:#1}}
\newcommand{\refrem}[1]{Remark~\ref{Rem:#1}}
\newcommand{\refclaim}[1]{Claim~\ref{Claim:#1}}
\newcommand{\refconj}[1]{Conjecture~\ref{Conj:#1}}
\newcommand{\refeqn}[1]{\eqref{Eqn:#1}}
\newcommand{\refitm}[1]{\eqref{Itm:#1}}
\newcommand{\refdef}[1]{Definition~\ref{Def:#1}}
\newcommand{\refsec}[1]{Section~\ref{Sec:#1}}
\newcommand{\reffig}[1]{Figure~\ref{Fig:#1}}

\newcommand{\clem}[1]{ \color{red}{#1} \color{black}{}}

\title{Détails sur la branche zigzag-filtration-simplex-tree de gudhi-devel}
\author{Cl\'ement Maria}

\begin{document}

\maketitle

% SIMPLEX\_TREE\_STAR\_SIMPLEX\_ITERATORS\_ ok
% SIMPLEX\_TREE\_H\_                      ...

% Point\_cloud.h            ok
% Zigzag\_persistence.h
% Simplex\_tree.h

% Simplex\_tree\_zigzag\_iterators.h
% indexing\_tag.h           ok


% Bonjour à tous,

% comme vous avez du le voir, je viens de soumettre une grosse mise à jour de ma branche   ...

% Comme demandé plus tôt par Marc, voici une explication des différentes composantes (essentiellement indépendantes les unes des autres, mais nécessaires pour faire tourner des exemples).


\section{Calcul rapide de la star d'un simplexe}

L'algorithme suivant est décrit dans l'article sur le Simplex tree. Il part du principe suivant : pour un simplexe s, dont l'étiquette maximale d'un de ses sommets est u, l'ensemble de ses cofaces (s compris) dans le simplex tree est représenté par un ensemble de sous-arbre, dont les racines ont pour étiquette u. L'algorithme consiste à trouver les racines de ces sous-arbre, et à traverser tous leurs noeuds.

Pour l'implémentation :


\subsection{Relier les n\oe uds avec même étiquette}

Il faut relier dans une liste $L\_u$ tous les noeuds de l'arbre avec étiquette $u$ (et ce pour toute étiquette $u$) pour une recherche rapide des candidats pour être racine. Cette propriété est maintenue à tout moment dans la construction du Simplex\_tree. C'est implémenté en donnant :

\begin{itemize}
\item La possibilité de maintenir deux \emph{boost hooks} pour que tous les {\tt Node} avec la même {\tt Simplex\_key} soient reliés dans une même liste intrusive. L'implémentation se fait par la création de deux classes :

\medskip

{\tt Hooks\_simplex\_base\_dummy} (vide), et
{\tt Hooks\_simplex\_base\_link\_nodes} (contenant un boost intrusive list member hook),

\medskip

et d'un std::conditional pour choisir celle que l'on veut (appelée {\tt Hooks\_simplex\_base}), et d'un héritage de {\tt Node} (dans {\tt Simplex\_tree\_node\_explicit\_storage.h}) depuis {\tt Hooks\_simplex\_base}.

\medskip

Ce mécanisme est commandé par la nouvelle entrée {\tt static const bool link\_nodes\_by\_label = true} dans les modèles de {\tt SimplexTreeOptions} (fin du fichier {\tt Simplex\_tree.h}).

\item Si {\tt link\_nodes\_by\_label == true}, il faut également maintenir les listes intrusives. Cela est fait par l'introduction de deux structures :

\medskip

{\tt nodes\_by\_label\_dummy} (empty, pour le cas {\tt link\_nodes\_by\_label == false}), et 
{\tt nodes\_by\_label\_intrusive\_list} (qui contient une map : "étiquette $u$ -> pointeur vers une liste intrusive contenant tous les noeuds d'étiquette $u$).

Un {\tt std::conditional} sur {\tt Options::link\_nodes\_by\_label} permet de choisir quel type on veut, et on stocke une telle structure comme membre de la classe {\tt Simplex\_tree}:

\medskip

  {\tt Nodes\_by\_label\_data\_structure        nodes\_by\_label\_;}

\medskip

Au passage, l'utilisation de structure intrusive m'oblige à travailler avec des {\tt Node}, contrairement à des {\tt Simplex\_handle} (i.e., itérateurs de {\tt value\_type pair<Simplex\_key,Node>}). J'ai donc du re-implémenter les fonctions {\tt "self\_siblings", "dimension"}, et {\tt "has\_children"} en prenant un {\tt Simplex\_key} et un {\tt Node} en entrée (à la place du {\tt Simplex\_handle} habituel).

\medskip

Finalement, l'insertion et la suppression d'un n\oe ud entraînent des changements plus grand dans le {\tt Simplex\_tree}, notamment le fait que les listes intrusives décrites plus haut sont modifiées. J'ai implémenté ça par l'ajout de deux fonctions membres :

\medskip

  {\tt void update\_simplex\_tree\_after\_node\_insertion(Simplex\_handle sh)} et
  
\smallskip

  {\tt void update\_simplex\_tree\_before\_node\_removal(Simplex\_handle sh)},

\medskip

qui, d'une part, met à jours toutes les structures additionnelles une fois que le simplex a été inséré dans un {\tt Siblings} (et a désormais un {\tt Simplex\_handle}), et, d'autre part, prépare le complexe à la suppression d'un simplex avant d'être enlevé de son {\tt Siblings} (et donc avec toujours un {\tt Simplex\_handle} toujours valide). Ces fonctions gèrent les listes intrusives, et seront utiles pour implémenter la théorie de Morse discrète (j'en parlerai plus bas). 

\end{itemize}

\subsection{De nouveaux itérateurs de star}

J'ai implémenté de nouveaux itérateurs (dans le fichier {\tt Simplex\_tree/Simplex\_tree\_star\_simplex\_iterators.h}) pour calculer la star d'un simplexe. Précisémment :

\begin{itemize}
%
\item {\tt class Simplex\_tree\_optimized\_cofaces\_rooted\_subtrees\_simplex\_iterator} : pour un simplex $\sigma$ donné, d'étiquette maximale $u$, implémente un itérateur parcourant tous les n\oe uds du simplex tree d'étiquette $u$ (en utilisant les listes intrusives) avec un filtre (``filter iterator'') pour ne garder que les cofaces de $\sigma$.
%
\item {\tt class Simplex\_tree\_optimized\_star\_simplex\_iterator} : iterateur sur les cofaces d'un simplex $\sigma$ ($\sigma$ compris), qui utilise un {\tt Simplex\_tree\_optimized\_cofaces\_rooted\_subtrees\_simplex\_iterator} pour trouver les sous-arbres contenant les cofaces, et parcourt ces sous-arbres (en largeur).
\end{itemize}

Dans {\tt Simplex\_tree.h}, il nous faut le bon type pour {\tt Star\_simplex\_iterator}. J'ai donc ajouté les {\tt typedef} :

\medskip

  {\tt typedef Simplex\_tree\_optimized\_star\_simplex\_iterator<Simplex\_tree> 
                                                    Optimized\_star\_simplex\_iterator;}

\medskip

  {\tt typedef boost::iterator\_range<Optimized\_star\_simplex\_iterator> 
                                                       Optimized\_star\_simplex\_range;}

\medskip

et un {\tt std::conditional} sur {\tt Options::link\_nodes\_by\_label} pour definir le {\tt typedef Star\_simplex\_range}.

J'ai également un {\tt constexpr(Options::link\_nodes\_by\_label)} dans 
{\tt Star\_simplex\_range star\_simplex\_range(const Simplex\_handle simplex)} 
car les implémentations sont différentes (pour la version non-optimisée, on se rapporte à un calcul de cofaces normal).


\begin{remark}
À noter que, pour le moment, cet itérateur calcule toutes les cofaces (la star) et pas celles d'une dimension donnée. Cependant, on pourra relativement facilement raffiner l'implémentation de {\tt class Simplex\_tree\_optimized\_star\_simplex\_iterator} pour discriminer sur la dimension. On devrait observer un gain intéressant sur la calcul de cofaces brute force.
\end{remark}




\section{Construction de filtration zigzag de flag complexe (partie combinatoire)}

Étant donnée un range d'insertions et de suppressions de sommets et d'arêtes (i.e., une filtration zigzag du $1$-squelette), faire les expansions et suppressions appropriées dans le {\tt Simplex\_tree} à la volée.

\subsection{Modificateur du simplex tree}

Implémentation dans {\tt Simplex\_tree.h} de

\begin{itemize}
\item la possibilité d'utiliser une {\tt boost::container::map} pour stocker les {\tt Node} d'un {\tt Sibling}, à la place d'une {\tt flat\_map} qui est moins dynamique (on fait beaucoup d'insertions et de suppressions de simplexes dans une filtration zigzag). De plus, mon implémentation des filtrations zigzag {\bf requiert} que les {\tt Simplex\_handle} (ici des {\tt map::iterator} donc) restent valide pendant toute la période où un simplex est dans le complexe (ce n'est pas le cas dans les {\tt flat\_map} qui "bougent" en mémoire).

Cette possibilité est donnée par la nouvelle entrée ``{\tt static const bool simplex\_handle\_strong\_validity = true;}'' dans les modèles de
{\tt SimplexTreeOptions}, et par un {\tt std::conditional} pour le {\tt typedef Dictionary}.

\item nouvelles fonctions membre :

\medskip

{\tt flag\_add\_edge} -> permet d'ajouter un sommet ou une arête, et de faire l'expansion du complexe jusqu'à la dimension maximale autorisée. Tous les nouveaux simplexes sont enregistrés dans un vecteur. Le {\tt Simplex\_tree} est {\em modifié}.

{\tt flag\_add\_edge} dépend de plusieurs fonctions "{\tt zz\_punctual\_expansion, zz\_local\_expansion, zz\_siblings\_expansion}", qui implémentent différents cas d'expansion locale, et {\tt zz\_intersection} qui fait des intersections de Siblings.

\medskip

{\tt flag\_lazy\_remove\_edge} -> enregistre (sans modifier le {\tt Simplex\_tree}) toutes les cofaces d'un sommet ou d'une arête qu'on veut supprimer, en utilisant le {\tt Star\_simplex\_iterator}.

\medskip

{\tt flag\_lazy\_empty\_complex} -> la même chose, mais pour tout supprimer, en utilsant le {\tt Complex_simplex_iterator}.

\medskip

Dans ces deux dernières fonctions, la suppression effective des simplexes dans le complexes se fait avec le traditionnel {\tt remove_maximal_simplex(sh)}, déjà implémenté.

\item de nouveaux itérateurs de filtration zigzag dans le fichier {\tt Simplex\_tree/Simplex\_tree\_zigzag\_iterators.h}. 

Dans {\tt Simplex\_tree.h}, cela se traduit par l'introduction d'un type "{\tt Zigzag\_filtration\_simplex\_iterator}" et "{\tt Zigzag\_filtration\_simplex\_range}", et "{\tt Filtration\_simplex\_range}" est choisi en fonction d'un {\tt std::conditional} sur {\tt Options::is\_zigzag} (nouvelle option du simplex tree).

L'interface pour accéder à la filtration est toujours avec 
{\tt filtration\_simplex\_range(...)}, mais dépend désormais d'un {\tt linear\_indexing\_tag} (filtration standard) ou d'un {\tt zigzag\_indexing\_tag}.

\begin{remark}
{\tt linear\_indexing\_tag/zigzag\_indexing\_tag} et {\tt bool is\_zigzag} sont redondants dans les {\tt Options}. Je propose d'utiliser un {\tt constexpr(Options::is\_zigzag)} (que je trouve plus lisible) pour {\tt filtration\_simplex\_range} (et les autres fonctions où {\tt linear\_indexing\_tag} est utilisé), et de supprimer ces {\tt indexing\_tag}. Qu'en pensez-vous ?

Certaines fonctions, comme "{\tt Simplex\_handle simplex(Simplex\_key idx)}", qui n'ont pas de version en persistence zigzag, pourraient utiliser un "{\tt std::false\_type}" en input, auquel cas on appelerait "{\tt simplex(key, Options::is\_zigzag)}". Je pense que ça déclenchera toujours une erreur à la compilation ?
\end{remark}

\item Ces nouveaux itérateurs zigzag sont implémentés dans {\tt Simplex\_tree/Simplex\_tree\_zigzag\_iterators.h}. Ce fichier contient :

\begin{itemize}
\item un type {\tt Zigzag\_edge} qui encode une arête $\{u,v\}$, ou un sommet $\{u\}$ (auquel cas on a $u=v$).
\item un ensemble de méthodes géométriques ({\tt compute\_epsilon\_values, zigzag\_filtration\_one\_skeleton}) qui permettent de calculer une filtration zigzag du $1$-squelette (insertion et suppressions de sommets et d'arêtes) à partir d'un nuage de points géométriques (par calculer une \emph{oscillating Rips zigzag filtration}). Je les décris dans la section suivante.
\item la classe {\tt Flagzigzag\_simplex\_iterator} qui, à partir d'une filtration zigzag du $1$-squelette (membres {\tt std::vector< Edge_type > zigzag\_edge\_filtration\_;}), implémente un itérateur de la filtration zigzag complète, en maintenant un {\tt Simplex\_tree} et en appelant dessus, et à la volée, les diverses fonctions d'expansion décrites plus haut. 

\smallskip

Cet itérateur est de {\tt value\_type Simplex\_handle}. À noter que cet itérateur maintient plus de méthodes publiques que d'habitude. Notamment {\tt arrow\_direction} (qui indique s'il s'agit d'une insertion ou d'une suppression) et {\tt filtration()} (qui donne la valeur de filtration associée à l'insertion/suppression du simplexe sur lequel on pointe ; ceci est du au fait que la valeur de filtration d'une suppression de simplexe n'est pas égale à celle stockée dans le simplexe tree, qui est la valeur de filtration au moment de l'insertion de ce simplexe).

\end{itemize}







\section{La partie géométrique de la construction de filtration zigzag : les oscillating Rips}

Ces méthodes géométriques permettent de calculer l'oscillating Rips zigzag filtration du $1$-squelette du complexe, à partir d'un nuage de points. 

\begin{remarque}
J'ai mis ces méthodes dans {\tt Simplex\_tree/Simplex\_tree\_zigzag\_iterator.h} car, bien que géométriques et assez différentes de la nature combinatoire de tout ce qui se trouve dans le simplex tree, elles ne semblent utiles que dans le contexte de l'oscillating Rips zigzag. Leur position dans le code est débattable.  
\end{remarque}

Nous avons donc :

\begin{itemize}
\item Deux versions de {\tt zigzag_filtration_one_skeleton}, l'une prend en entrée une matrice de distances et calcule l'oscillating Rips zigzag filtration du $1$-squelette, et l'autre qui prend en entrée des points et une fonction distance, pré-calcule l'ensemble des distance deux à deux en appelle la première fonction. Cette dernière fonction calcule un ordre sur les points du nuage, selon trois politiques : {\tt already\_ordered, farthest\_point\_ordering, random\_point_\_ordering}.
%
\item La fonction {\tt compute\_epsilon\_values} computes, for an ordered point cloud $P = \{p_0, \ldots ,p_{n-1}\}$, the values $\varepsilon_i = d_H(P, P_i)$, where $P_i = \{p_0, \ldots , p_i$.
\end{itemize}



\section{La théorie de Morse discrète}

J'ai implémenté une bonne partie des mécanismes, mais il me manque le calcul de bord dans un complexe de Morse. Du coup, tout est en commentaire. Je décris quand même les mécanismes :

La volonté de faire la théorie de Morse discrète est donnée par {\tt Options::store\_morse\_matching} dans le simplex tree. On a :

\begin{itemize}
\item la possibilité de stocker un {\tt Simplex\_handle} dans chaque Node, pour représenter le simplex avec lequel on forme une paire de Morse. Implémenté par les deux classes 

{\tt Pairing\_simplex\_base\_dummy} (vide) et {\tt Pairing\_simplex\_base\_morse} (contient un membre {\tt Simplex\_handle}) dont {\tt Simplex\_tree\_node\_explicit\_storage} hérite.

\item des méthodes "{\tt paired\_with, critical, assign\_pairing, make\_critical, is\_paired\_with}" dans la {\tt classe Simpex\_tree} pour atteindre l'information au sujet des paires de Morse.

\item un appel à "{\tt Discrete\_morse\_theory<Simplex\_tree>().compute\_matching}" quand on insère un ensemble de simplexe avec la même valeur de filtration (par exemple dans {\tt flag\_add\_edge}). Cette méthode calcule un appariement de Morse (c'est dans le paquetage {\tt Discrete\_morse\_theory} qui sera amené à contenir l'opération de bord) et stocke l'information dans les noeuds du simplex tree.

\item une mise à jour des noeuds dans les fonctions :

  {\tt void update\_simplex\_tree\_after\_node\_insertion(Simplex\_handle sh)} -> un nouveau simplex est critique par défaut,

  {\tt void update\_simplex\_tree\_before\_node\_removal(Simplex\_handle sh)} -> en enlevant un simplex non-critique, il faut rendre le simplex, avec lequel il forme une paire de Morse, critique.

\item des fonctions de mise à jour dans les opérateurs de filtration zigzag du simplex tree.



\section{Petites opérations sur les nuages de points}

J'ai ajouté un dossier {\tt Computational\_geometry} avec un fichier {\tt Point\_cloud.h}, qui implémente des méthodes simples sur les nuages de points : chercher et éliminer les doublons, perturbations aléatoires, vérifier que deux paires de points (distincts) $x,y,z,t$ ne soient pas à la même distance, i.e., $d(x,y) \neq d(z,t)$. Cette dernière opération de généricité est très utile en persistence zigzag. Elle est également utile pour qu'un "farthest point sampling" d'un nuage de points soit unique une fois qu'on a choisi le premier point (utilisé dans ma construction de l'oscillating Rips zigzag filtration).


\section{Homologie persistante zigzag}

src/Zigzag\_persistence/
  avec le fichier Zigzag\_persistence.h Implémente la persistence zigzag avec coefficients dans $\ZZ/2\ZZ$.


\section{Données}

J'ai ajouté un jeu de données {\tt data/points/S3\_in\_R4\_2k\_uniform.off}. Il s'agit d'un échantillonage uniforme de $2000$ points sur la $3$-sphère unité dans $\RR4$. C'est un cas intéressant pour la persistence zigzag qui permet de reconstruire et d'inférer l'homologie de $3$-variétés.


\section{To do et à débattre}

\begin{itemize}
\item Implémenter, dans le Simplex\_tree, un coefficient pour l'opérateur de bord. Dans un complexe simnplicial, c'est un +/- 1, qu'on connait d'avance dans le Simplex tree. Idée : ajouter une méthode {\tt .coefficient()} dans le {\tt Boundary\_simplex\_iterator} qui renvoie un {\tt int}.

Concerne le calcul de bord dans {\tt Discrete\_morse\_theory}, le calcul de persistence avec coefficients.
\end{itemize}

\end{document}